import sqlite3 from 'sqlite3';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import bcrypt from 'bcryptjs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const DB_PATH = join(__dirname, '..', 'data', 'neurochat.db');

// ========================================================================================
// CONFIGURATION DE LA BASE DE DONN√âES
// ========================================================================================

let db;

/**
 * Initialise la connexion √† la base de donn√©es
 */
function getDatabase() {
  if (!db) {
    db = new sqlite3.Database(DB_PATH, (err) => {
      if (err) {
        console.error('‚ùå Erreur de connexion √† la base de donn√©es:', err.message);
        throw err;
      }
      console.log('‚úÖ Connexion √† la base de donn√©es SQLite √©tablie');
      
      // Activer les contraintes de cl√©s √©trang√®res
      db.run('PRAGMA foreign_keys = ON');
      
      // Activer le mode WAL pour de meilleures performances
      db.run('PRAGMA journal_mode = WAL');
      
      // Optimiser la base de donn√©es
      db.run('PRAGMA optimize');
    });
  }
  return db;
}

/**
 * Cr√©e les tables de la base de donn√©es
 */
async function createTables() {
  return new Promise((resolve, reject) => {
    const database = getDatabase();
    
    // Table des utilisateurs
    const createUsersTable = `
      CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username VARCHAR(50) UNIQUE NOT NULL,
        email VARCHAR(100) UNIQUE NOT NULL,
        password_hash VARCHAR(255) NOT NULL,
        encryption_key_hash VARCHAR(255) NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        last_login DATETIME,
        is_active BOOLEAN DEFAULT 1,
        preferences TEXT
      )
    `;
    
    // Table des conversations
    const createConversationsTable = `
      CREATE TABLE IF NOT EXISTS conversations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        title VARCHAR(255) NOT NULL,
        workspace_id VARCHAR(100) DEFAULT 'default',
        child_mode BOOLEAN DEFAULT 0,
        private_mode BOOLEAN DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        message_count INTEGER DEFAULT 0,
        tags TEXT,
        metadata TEXT,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      )
    `;
    
    // Table des messages
    const createMessagesTable = `
      CREATE TABLE IF NOT EXISTS messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        conversation_id INTEGER NOT NULL,
        content TEXT NOT NULL,
        is_user BOOLEAN NOT NULL,
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
        message_order INTEGER NOT NULL,
        metadata TEXT,
        FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
      )
    `;
    
    // Table des embeddings pour recherche s√©mantique
    const createEmbeddingsTable = `
      CREATE TABLE IF NOT EXISTS message_embeddings (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        message_id INTEGER NOT NULL,
        embedding_data TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE
      )
    `;
    
    // Table des sessions utilisateur
    const createSessionsTable = `
      CREATE TABLE IF NOT EXISTS user_sessions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        session_token VARCHAR(255) UNIQUE NOT NULL,
        expires_at DATETIME NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        last_activity DATETIME DEFAULT CURRENT_TIMESTAMP,
        ip_address VARCHAR(45),
        user_agent TEXT,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      )
    `;
    
    // Table des statistiques d'utilisation
    const createStatsTable = `
      CREATE TABLE IF NOT EXISTS usage_stats (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        date DATE NOT NULL,
        messages_sent INTEGER DEFAULT 0,
        messages_received INTEGER DEFAULT 0,
        conversations_created INTEGER DEFAULT 0,
        total_tokens INTEGER DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
        UNIQUE(user_id, date)
      )
    `;
    
    // Cr√©ation des tables dans l'ordre (d√©pendances)
    const tables = [
      { name: 'users', sql: createUsersTable },
      { name: 'conversations', sql: createConversationsTable },
      { name: 'messages', sql: createMessagesTable },
      { name: 'message_embeddings', sql: createEmbeddingsTable },
      { name: 'user_sessions', sql: createSessionsTable },
      { name: 'usage_stats', sql: createStatsTable }
    ];
    
    let completed = 0;
    const totalTables = tables.length;
    
    tables.forEach(({ name, sql }) => {
      database.run(sql, (err) => {
        if (err) {
          console.error(`‚ùå Erreur cr√©ation table ${name}:`, err.message);
          reject(err);
          return;
        }
        
        completed++;
        console.log(`‚úÖ Table ${name} cr√©√©e/v√©rifi√©e`);
        
        if (completed === totalTables) {
          resolve();
        }
      });
    });
  });
}

/**
 * Cr√©e un utilisateur administrateur par d√©faut
 */
async function createDefaultAdmin() {
  return new Promise((resolve, reject) => {
    const database = getDatabase();
    
    // V√©rifier si l'admin existe d√©j√†
    database.get('SELECT id FROM users WHERE username = ?', ['admin'], (err, row) => {
      if (err) {
        reject(err);
        return;
      }
      
      if (row) {
        console.log('‚ÑπÔ∏è Utilisateur admin d√©j√† existant');
        resolve();
        return;
      }
      
      // Cr√©er l'admin par d√©faut
      const defaultPassword = 'admin123';
      const saltRounds = 12;
      
      bcrypt.hash(defaultPassword, saltRounds, (err, hash) => {
        if (err) {
          reject(err);
          return;
        }
        
        // Cl√© de chiffrement par d√©faut (√† changer en production)
        const defaultEncryptionKey = 'default_encryption_key_change_in_production';
        bcrypt.hash(defaultEncryptionKey, saltRounds, (err, encryptionHash) => {
          if (err) {
            reject(err);
            return;
          }
          
          const insertAdmin = `
            INSERT INTO users (username, email, password_hash, encryption_key_hash, preferences)
            VALUES (?, ?, ?, ?, ?)
          `;
          
          const preferences = JSON.stringify({
            theme: 'dark',
            language: 'fr',
            autoRagEnabled: true,
            autoWebEnabled: false,
            ttsEnabled: false
          });
          
          database.run(insertAdmin, [
            'admin',
            'admin@neurochat.local',
            hash,
            encryptionHash,
            preferences
          ], function(err) {
            if (err) {
              reject(err);
              return;
            }
            
            console.log('‚úÖ Utilisateur admin cr√©√© avec succ√®s');
            console.log('‚ö†Ô∏è  ATTENTION: Changez le mot de passe par d√©faut en production!');
            resolve();
          });
        });
      });
    });
  });
}

/**
 * Cr√©e les index pour optimiser les performances
 */
async function createIndexes() {
  return new Promise((resolve, reject) => {
    const database = getDatabase();
    
    const indexes = [
      'CREATE INDEX IF NOT EXISTS idx_conversations_user_id ON conversations(user_id)',
      'CREATE INDEX IF NOT EXISTS idx_conversations_workspace_id ON conversations(workspace_id)',
      'CREATE INDEX IF NOT EXISTS idx_conversations_created_at ON conversations(created_at)',
      'CREATE INDEX IF NOT EXISTS idx_messages_conversation_id ON messages(conversation_id)',
      'CREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages(timestamp)',
      'CREATE INDEX IF NOT EXISTS idx_messages_order ON messages(conversation_id, message_order)',
      'CREATE INDEX IF NOT EXISTS idx_sessions_user_id ON user_sessions(user_id)',
      'CREATE INDEX IF NOT EXISTS idx_sessions_token ON user_sessions(session_token)',
      'CREATE INDEX IF NOT EXISTS idx_stats_user_date ON usage_stats(user_id, date)'
    ];
    
    let completed = 0;
    const totalIndexes = indexes.length;
    
    indexes.forEach((sql, index) => {
      database.run(sql, (err) => {
        if (err) {
          console.error(`‚ùå Erreur cr√©ation index ${index}:`, err.message);
          reject(err);
          return;
        }
        
        completed++;
        if (completed === totalIndexes) {
          console.log('‚úÖ Index de performance cr√©√©s');
          resolve();
        }
      });
    });
  });
}

/**
 * Fonction principale d'initialisation
 */
export async function setupDatabase() {
  try {
    console.log('üóÑÔ∏è Initialisation de la base de donn√©es...');
    
    // Cr√©er le dossier data s'il n'existe pas
    const fs = await import('fs');
    const dataDir = join(__dirname, '..', 'data');
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
      console.log('üìÅ Dossier data cr√©√©');
    }
    
    // Cr√©er les tables
    await createTables();
    
    // Cr√©er les index
    await createIndexes();
    
    // Cr√©er l'utilisateur admin par d√©faut
    await createDefaultAdmin();
    
    console.log('‚úÖ Base de donn√©es initialis√©e avec succ√®s');
    
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'initialisation de la base de donn√©es:', error);
    throw error;
  }
}

/**
 * Ferme la connexion √† la base de donn√©es
 */
export function closeDatabase() {
  if (db) {
    db.close((err) => {
      if (err) {
        console.error('‚ùå Erreur fermeture base de donn√©es:', err.message);
      } else {
        console.log('‚úÖ Connexion √† la base de donn√©es ferm√©e');
      }
    });
  }
}

// Export de la fonction getDatabase pour utilisation dans d'autres modules
export { getDatabase };
